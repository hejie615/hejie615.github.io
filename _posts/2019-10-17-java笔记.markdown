---
layout: post
title: Java随笔
date: 2019-10-17 09:00:00 +0300
description: You’ll find this post in your `_posts` directory. Go ahead and edit it and re-build the site to see your changes. # Add post description (optional)
img: java.jpg # Add image post (optional)
tags: [Java随笔] # add tag
---

### 1.相关概念

1. jdk：Java开发工具包，只要做Java开发就需要下载和安装该软件。
2. jre：Java运行时环境信息，只要运行Java程序就需要下载和安装该软件。
3. jvm：Java虚拟机，是Java程序与计算机操作系统之间的桥梁。（java程序要在操作系统上运行需要jvm解析）
4. javac.exe：Java的编译器，进行编译生成字节码文件
5. java.exe：Java的解释器，用于启动Java虚拟机对字节码文件进行解释执行
6. 环境变量path：可执行文件在任意路径都可以使用，把javac.exe所在路径复制到path最前面

### 2.变量

1. 变量使用前必须声明和初始化，
2. 变量不能重复声明

### 3.输入输出

1. 输出
	System.out.printIn();
2. 扫描键盘的输入

	Scanner sc = new Scanner(); //需要导入import java.util.Scanner;

	变量 = sc.next() //读取一个字符串

	变量 = sc.nextInt() //读取一个整数

### 4.数据类型

>注意：	
> + 加粗为推荐使用
> + 超出范围赋值会报错
> + 常量过大需加L或l(超过10位)
> + 整数常量默认为int类型，小数常量默认为double类型(若要表达为float可以在后面加f或F)
> + float小数点7位，double小数点15位
> + 默认为double的常量定义成float会报错，需要加f或F
> + 强转成小类型会截断 数据会丢失
> + int默认0 double默认0.0 string默认null boolean默认false

1. 基本数据类型(内存占用空间字节数)

	byte(1) short(2) **int(4)** long(8) float(4) **double(8)** boolean char(2)
2. 引用数据类型

	数组 类 接口 注解 枚举


---------

### 5.算数运算符
 
> + 两个整数相除得整数,丢弃小数部分（强转double或者乘以1.0推荐）
> + 整数运算0做除数不会报错 会出现算数异常，浮点运算0.0结果是无穷但不会报错


### 6.数组

1. 一维数组的声明
	* 数据类型[] 数组名称 = new 数据类型[数组的长度]（或者int arr[]）
	* 数据类型[] 数组名称 = new 数据类型[]{数据...}
	* 数据类型[] 数组名称 = {数据....}（是上面的简化版）

> + 数组元素不赋值也会有默认值
> + 数组只能在初始化的时候用大括号给值
> + 二维数组必须声明行，列可以省略（再重新声明每列）

2. 二维数组的声明

	数据类型[][] 数组名称 = new 数据类型[行数][列数]
	//同一维数组

## 面向对象

> this关键字
> + 在构造方法中this指向当前构造的对象
> + 在成员方法中谁调用该方法this就指向谁
> + 在成员方法中访问成员变量时默认会加上this.
> + this放在构造方法的第一行，可以调用本类的其他构造方法

### 一. 概念

1. 面向对象

	指以特征（属性）和行为的观点去分析现实世界中事务的方式
2. 面向对象编程

	指先使用面向对象的方式进行分析，再使用任意一门面向对象的编程语言进行翻译的过程

3. 三大特征

	封装、继承、多态

### 二. 定义

> + 局部变量： 主要值在方法体中声明的变量，作用范围从声明开始到方法体结束
> + 成员变量： 主要指在方法体外类体内声明的变量，作用范围从声明到类体结束

#### 1.类的定义

```
（1）类定义的语法格式
	class 类名{
		类体;
	}

（2）成员变量定义的语法格式
	class 类名{
		数据类型 成员变量名 = 初始值;	//分号不能省略
	}

（3）成员方法定义的语法格式
	class 类名{
		返回值类型 成员方法名(形参列表){
			成员方法体;
		}
	}

注意：
1. 类名每个单词首字母大写（规范）
2. 成员变量和成员方法从第二个单词起首字母大写（规范）
3. 成员方法的接收的实参必须和形参个数，类型，顺序保持一致 
```

#### 2.对象的创建

```
（1）语法格式
	new 类名();	//并没有引用赋值给一个变量，该对象叫做“匿名对象”

注意：
1. 使用new创建对象的过程叫 类的实例化
2. 创建对象就是在内存中堆区开辟一块存储空间，来存放该对象独有的特征信息
```

#### 3.引用

在java中使用引用数据类型声明的变量叫引用型变量，简称为引用。主要用于记录对象在堆区中的地址信息(指向对象的地址)

```
（1）语法格式
	类名 引用变量名;
如：
	Person p = new Person();	//表示声明Person类型引用变量p来记录Person类型对象的地址信息（引用变量在栈区开辟存储空间）
（2）使用
	引用变量名.成员变量名;
如：
	p.name = "zhangsan";
```

#### 4.构造方法

```
（1）语法格式
	class Person{
		Person(){
		}
	}

注意：
1. 构造方法的名称与类名完全相同，没有返回值类型，void也不能有。
2. 构造方法用来给成员变量初始化
3. 当类中没有定义任何形式的构造方法时，编译器会自动添加一个无参的空构造方法，叫做默认/缺省构造方法，如：Person(){}
4. 若在类中自定义构造方法，编译器将不提供空构造方法
```

#### 5.构造方法的重载（overload）

* 在java中若方法的名称相同但参数列表不同，这样的方法之间构成重载关系
* 方法重载的主要形式有：参数的个数不同、参数的类型不同、参数的顺序不同，与形参名和返回值类型无关，返回值类型最好相同。
* 实际意义：一个方法名就可以调用各种不同的版本实现不同的效果。如：pringIn()能输出各种格式

#### 6.封装

> + 封装就是一种保证成员变量值合理性的机制。
> + private修饰成员变量表示私有的含义，该成员变量只能在本类的内部使用。
> + public修饰成员方法表示公有的，该方法可以在任意位置调用（若方法前面啥也不加表示默认权限，访问级别低于public）

1. 使用private关键字私有化成员变量（private修饰成员变量表示私有的含义，该成员变量只能在本类的内部使用）
2. 提供公有的get和set方法，在方法体中进行判断，如果输入值合理则进行赋值
3. 在构造方法中调用set方法进行合理值的判断

#### static关键字

> static修饰的成员跟随类产生而产生，非静态成员变量只有在创建对象后才能使用
> 类似于js的prototype上的属性，是对象共有的一个相同点继承给所有创建的对象，避免空间浪费
> 一个对象修改static修饰的成员，其他对象的该成员也会发生改变
1. static修饰成员变量，表示静态，该成员变量由对象层级提升为类层级被所有对象共享(继承该变量)，该成员变量随类的加载准备就绪，与是否创建对象无关
2. static关键字也可以修饰成员方法，推荐使用 类名. 的方式访问
3. 静态成员只能访问静态成员不能访问非静态成员（相当于作用域问题，类层级肯定不能访问到对象层级）
4. 所有对象都有的一个共同点才用static修饰，节省空间否则没有意义 

#### 单例设计模式

> + 一个类只需要创建一个对象，不需要第二个，使用单例模式
> + 饿汉式：在本类里先创建对象，推荐
> + 懒汉式：先把引用指向null，有人需要对象的时候再创建对象

1. 先private私有化构造方法，阻止外部去创建对象
2. 声明本类类型的引用指向本类创建的对象，定义为private私有化并且加上static属性 否则将无法访问（成员变量只能创建对象后使用，所以用static修饰），只能通过static用类.访问
3. 对外提供一个get方法，把唯一的对象传出去，使用static关键字修饰（构造方法私有化只能通过static使用 类.的方式访问）

#### 继承

1. 概念
	* 当多个类之间有相同的特征和行为时，可以将相同的内容提取出来组成一个公共类，而在多个类的内部编写自己独有特征和行为
2. 使用方式
	* extends关键字
```
public class Student extends Person{} 	//表示Student类继承自Person类
	
注意：
	1. 子类可以继承父类的成员变量和成员方法，其中私有成员变量可以继承但不可以直接使用(因为封装了)，子类不可以继承父类的构造方法和私有方法（构造方法因为继承下来也没有用）。
	2. 在构造子类对象时，会自动调用父类中的无参构造方法来初始化从父类继承下来的成员变量，相当于在子类构造方第一行隐式的写了super()代码（调用父类的构造方法，super父类），一般自己写super初始化继承下来的成员变量
	3. 一个子类只能有一个父类，一个父类可以有多个子类
```

#### 方法的重写(Override)

1. 概念
	* 在子类中重新写一个与父类中一样的方法来覆盖从父类中继承的版本
2. 原则
	* 在重写方法的上一行写上@Override， 备注上的意思
	* 要求方法名相同、参数列表相同、返回值类型相同，从jdk1.5开始允许返回子类类型（子类方法重写返回值可以返回子类的类型）
	* 要求方法的访问权限不能变小，可以相同或者变大。
	* 要求不能抛出更大的异常（异常机制）。

#### 常用的访问控制符

```
访问控制符		访问权限		本类		本类中的包		子类		其他包中的其他类
public			公有的		ok		ok				ok		ok
protected		保护的		ok		ok				ok		no
啥也不写			默认的		ok		ok				no		no
private			私有的		ok		no				no		no
```

#### 包的定义

```
1. package 包名;
2. package 包名1.包名2...包名n;		//便于管理，避免命名冲突问题
```

#### final关键字

1. 概念
	* final本意为"最终的，不可更改的"，该关键字可以修饰类、成员方法、成员变量等。
2. 使用方法

```
①final修饰类：表示该类不能被继承。
	//防止滥用继承带来的危害
②final修饰成员方法：表示该方法不能被重写但可以被继承。
	//防止不经意间造成的方法重写
③final修饰成员变量：表示该成员变量必须初始化而且不能更改。（类似js的const）
	//为了防止不经意间造成数值的更改
```

#### 多态

1. 概念
	* 多态主要指同一种事务表现出来的多种形态。
	* 父类的引用指向一个子类的对象，形成多态
2. 语法格式
```
	父类类型 引用变量名 = new 子类类型();
如：
	Person pw = new Worker();
	pw.show();
解析：
	在编译阶段调用Person类中的show方法，在运行阶段调用Worker类中重写以后的show方法。（披着羊皮的狼）

多态的效果：
	①当父类的引用指向子类的对象时，父类的引用可以直接调用父类独有的方法；
	②当父类的引用指向子类的对象时，父类的引用不可以直接调用子类独有的方法；（只能使用父类中定义的属性和方法。编译时pw会被认为是Person类型所有会报错，通不过编译阶段）
	③对于父子类都有的非静态成员方法来说，编译阶段调用父类版本，运行阶段调用子类重写后的版本；（对于子类重写的方法，运行时使用子类重写的方法。在编译时父类也有该方法所有可以通过编译，但在运行时会被认为是子类类型，所以调用子类重写的方法）
	④对于父子类都有的静态方法来说，编译和运行阶段都调用父类版本，因为引用是父类类型的所以调用父类版本，因此与指向的对象无关；

注意：
	①编译时，pw被认为是Person类型；但在运行时是Worker类型；在内存中其实是子类对象。 *******
	②若要父类的引用想调用子类独有的方法，需通过强转为子类类型才能调用，就是让编译时pw也被认为是子类类型（如：(Worker)pw.getSalary();  ）

引用数据类型之间的转换
	①引用数据类型之间的转换分为： 自动类型转换  和  强制类型转换。
		自动类型转换主要指从小到大范围之间的转换，也就是子类到父类的转换。
		强制类型转换主要指从大到小范围之间的转换，也就是父类到子类的转换
	②引用数据类型之间的转换必须发生在父子类之间，否则编译报错。
	③若转换到的目标类型是子类类型但不是该引用真正指向的子类类型，则编译阶段通过，运行阶段因为在运行时pw被认为是Person类型不是父子类关系，所以在运行阶段会发生类型转换异常。（对象强转是一种还原行为，必须内存中是该类型的对象才能成功）
	④为了避免上述错误的发生，可以使用instanceof进行判断，具体格式如下：
		if(引用变量名 instanceof 数据类型)	//判断引用变量指向的对象是否为后面类型
	强转之前都应该instanceof一下

多态的意义：
	可以屏蔽不同子类的差异性实现通用的编程，但可以调用不同的方法带来不同的结果。
```

3. 是大法官和

#### 抽象类

1. 抽象方法的概念
	* 抽象方法就是指不能具体实现的方法，也就是没有方法体并使用abstract关键字修饰。
	

>持续更新……